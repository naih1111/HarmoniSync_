  // ============================================================================
  // REFACTORED PLAYBACK LOGIC - Extracted common functionality to eliminate duplication
  // ============================================================================
  
  /// Common playback timer logic used by both _startExercise and _resumeExercise
  void _startPlaybackTimer() {
    _scoreFuture.then((score) {
      if (!mounted) return;
      
      _playbackTimer = Timer.periodic(const Duration(milliseconds: 50), (timer) {
        if (!mounted) {
          timer.cancel();
          return;
        }
        
        setState(() {
          if (!_reachedEnd) {
            _updatePlaybackState(score);
          }
        });
      });
    });
  }
  
  /// Update the current playback state (time, notes, metronome)
  void _updatePlaybackState(Score score) {
    final double stopwatchSec = (_playbackStopwatch?.elapsedMicroseconds ?? 0) / 1e6;
    _currentTime = _elapsedBeforePauseSec + stopwatchSec;
    
    // Calculate total beats up to current time (used by metronome and note selection)
    final double metronomeBeatUnitSec = (60.0 / _bpm) * (4.0 / (_timeSigBeatType?.toDouble() ?? 4.0));
    final double currentBeats = _currentTime / metronomeBeatUnitSec;

    // End-of-sheet handling
    if (_currentTime >= _lastMeasurePosition) {
      _handleExerciseEnd();
      return;
    }
    
    // Handle metronome beats
    _handleMetronomeBeats(currentBeats, metronomeBeatUnitSec);
    
    // Find and update current note
    _updateCurrentNote(score, currentBeats);
  }
  
  /// Handle exercise completion
  void _handleExerciseEnd() {
    _reachedEnd = true;
    _isPlaying = false;
    _playbackTimer?.cancel();
    _stopPitchDetection();
    _stopMetronome();
    _showCompletionDialog();
  }
  
  /// Handle metronome beat timing
  void _handleMetronomeBeats(double currentBeats, double metronomeBeatUnitSec) {
    if (_metronomeEnabled) {
      final int targetBeat = currentBeats.floor();
      const double clickDurationSec = 0.05; // 50ms
      while (_lastWholeBeat < targetBeat) {
        _lastWholeBeat++;
        final int beatsPerMeasure = (_timeSigBeats ?? 4).clamp(1, 12);
        final bool isDownbeat = (_lastWholeBeat % beatsPerMeasure) == 0;
        final double beatStartSec = _lastWholeBeat * metronomeBeatUnitSec;
        if (beatStartSec + clickDurationSec <= _lastMeasurePosition) {
          _triggerMetronome(downbeat: isDownbeat);
        } else {
          break; // don't schedule beyond end
        }
      }
    }
  }
  
  /// Find and update the current note based on timing
  void _updateCurrentNote(Score score, double currentBeats) {
    double totalBeats = 0.0;
    int newNoteIndex = 0;
    bool foundNote = false;
    
    for (final measure in score.measures) {
      for (final note in measure.notes) {
        if (!note.isRest) {
          if (currentBeats >= totalBeats && currentBeats < totalBeats + _getNoteDuration(note)) {
            foundNote = true;
            break;
          }
          newNoteIndex++;
        }
        totalBeats += _getNoteDuration(note);
      }
      if (foundNote) break;
    }
    
    // Update expected/current note on index change or if not set yet
    if (newNoteIndex != _currentNoteIndex || _expectedNote == null) {
      _currentNoteIndex = newNoteIndex;
      _updateExpectedNote(score);
    }
  }

  /// Update BPM and restart systems if needed
  void _updateBpmAndRestart(double newBpm) {
    setState(() {
      _bpm = newBpm;
      if (_metronomeEnabled) {
        _startMetronome();
      }
      // Restart exercise with new BPM if currently playing
      if (_isPlaying) {
        _stopExercise();
        _startExercise();
      }
    });
  }
